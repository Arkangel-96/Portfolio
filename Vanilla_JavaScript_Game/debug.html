<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Ninja Debug Jump</title>
  <style>
    body {
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid white;
      background: #444;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="500" height="400"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// === VARIABLES ===
let x = 200, y = 350;
const spriteWidth = 80, spriteHeight = 80;
const speedRun = 5;
let facingRight = true;

let keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

let playerState = "idle";
let actionPlaying = false;
let jumping = false;
let velocityY = 0;
const jumpBoost = 7;
const gravity = 0.15;
let jumpHorizontalSpeed = 0;

// === ESCALADO X/Y ===
const scaleFactors = { 
  idle:        { x: 0.7, y: 1.0 }, 
  attack:      { x: 1.5, y: 1.2 },
  throw:       { x: 1.03, y: 1.03 },
  dead:        { x: 1.2, y: 1.2 },
  jump_attack: { x: 1.3, y: 1.3 },
  default:     { x: 1.0, y: 1.0 }
};

// === DELAYS POR ANIMACIÓN ===
const animationDelays = {
  idle: 10,
  jump: 12,
  default: 6
};

// === PROYECTILES ===
let projectiles = [];
function shootProjectile(startX, startY, direction) {
  projectiles.push({ x: startX, y: startY, speed: 6, dir: direction });
}

// === MODO DEBUG PARA JUMP ATTACK/THROW ===
let debugModeJumpAttacks = true;

// === ACTUALIZAR ESTADO ===
function updatePlayerState() {
  if (actionPlaying) return;

  if ((jumping || debugModeJumpAttacks) && keys["c"]) {
    playerState = "jump_attack";
    actionPlaying = true;
    return;
  }
  if ((jumping || debugModeJumpAttacks) && keys["v"]) {
    playerState = "jump_throw";
    actionPlaying = true;
    shootProjectile(x + spriteWidth / 2, y - spriteHeight / 2, facingRight ? 1 : -1);
    return;
  }
  if (keys["d"] && !jumping) {
    actionPlaying = true; playerState = "attack"; return;
  }
  if (keys["f"] && !jumping) {
    actionPlaying = true; playerState = "throw"; 
    shootProjectile(x + spriteWidth / 2, y - spriteHeight / 2, facingRight ? 1 : -1);
    return;
  }

  if (!jumping && keys["arrowup"]) {
    jumping = true;
    velocityY = -jumpBoost;
    if (keys["arrowleft"]) { jumpHorizontalSpeed = -2.5; facingRight = false; }
    else if (keys["arrowright"]) { jumpHorizontalSpeed = 2.5; facingRight = true; }
    else jumpHorizontalSpeed = 0;
    playerState = "jump";
  } else if (!jumping && (keys["arrowleft"] || keys["arrowright"])) {
    playerState = "run";
  } else if (!jumping) {
    playerState = "idle";
  }
}

// === ACTUALIZAR POSICIÓN ===
function updatePosition() {
  if (jumping) {
    velocityY += gravity;
    y += velocityY;
    x += jumpHorizontalSpeed;
    if (y >= 350) { y = 350; jumping = false; velocityY = 0; jumpHorizontalSpeed = 0; }
  }

  if (!jumping && playerState === "run") {
    if (keys["arrowleft"]) x -= speedRun;
    if (keys["arrowright"]) x += speedRun;
  }

  if (x < 0) x = 0;
  if (x > canvas.width - spriteWidth) x = canvas.width - spriteWidth;
}

// === GAME LOOP ===
function gameLoop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  updatePlayerState();
  updatePosition();

  // DIBUJAR PERSONAJE DEBUG
  ctx.save();
  const factor = scaleFactors[playerState] || scaleFactors.default;
  const drawW = spriteWidth * factor.x;
  const drawH = spriteHeight * factor.y;
  const offsetX = x + (spriteWidth - drawW)/2;
  const offsetY = y - drawH;
  
  ctx.fillStyle = "blue";
  ctx.fillRect(offsetX, offsetY, drawW, drawH);
  ctx.restore();

  // ACTUALIZAR Y DIBUJAR PROYECTILES
  for (let i = projectiles.length -1; i>=0; i--) {
    const p = projectiles[i];
    p.x += p.speed * p.dir;
    ctx.fillStyle = "green";
    ctx.fillRect(p.x, p.y, 10, 10);
    if (p.x < 0 || p.x > canvas.width) projectiles.splice(i,1);
  }

  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
