<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Ninja Debug Jump</title>
  <style>
    body {
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid white;
      background: #444;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="500" height="400"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// === CONFIGURACIÓN DE FRAMES ===
const frameCount = 10;
const animations = {
  run: [], idle: [], attack: [], throw: [],
  dead: [], slide: [], jump: [], jump_attack: [], jump_throw: []
};
let loaded = 0;

// Precarga de imágenes
function preloadImages(folder, array) {
  for (let i = 1; i <= frameCount; i++) {
    const img = new Image();
    img.src = `ninja/${folder}/frame_${i}.png`;
    img.onload = () => {
      loaded++;
      if (loaded === Object.keys(animations).length * frameCount) {
        requestAnimationFrame(gameLoop);
      }
    };
    array.push(img);
  }
}
for (let anim in animations) preloadImages(anim, animations[anim]);

// === VARIABLES DE ESTADO ===
let x = 200, y = 350;
const spriteWidth = 80, spriteHeight = 80;
const speedRun = 5;
let facingRight = true;

let actionPlaying = false;
const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

let playerState = "idle";
let currentFrame = 0;
let frameCounter = 0;

// === ESCALADO X/Y ===
const scaleFactors = { 
  idle:        { x: 0.7, y: 1.0 }, 
  attack:      { x: 1.5, y: 1.2 },
  throw:       { x: 1.03, y: 1.03 },
  dead:        { x: 1.2, y: 1.2 },
  jump_attack: { x: 1.3, y: 1.3 },
  default:     { x: 1.0, y: 1.0 }
};

// === DELAYS POR ANIMACIÓN ===
const animationDelays = {
  idle: 10,
  jump: 12,
  default: 6
};

// === SALTO MEJORADO Y LENTO ===
const jumpBoost = 7;
const gravity = 0.15;
let velocityY = 0;
let jumping = false;
let jumpHorizontalSpeed = 0;

// === MODO DEBUG PARA JUMP ATTACK/THROW ===
let debugModeJumpAttacks = true;

// === PROYECTILES ===
let projectiles = [];
const projectileImg = new Image();
projectileImg.src = "ninja/Kunai.png"; // imagen del Kunai

function shootProjectile(startX, startY, direction) {
  projectiles.push({ x: startX, y: startY, speed: 6, dir: direction });
}

// === ENEMIGO ===
const enemy = {
  x: x + 150, // 150px delante del ninja
  y: 350,     // mismo suelo
  width: spriteWidth,
  height: spriteHeight,
  color: "orange"
};

// === ACTUALIZAR ESTADO ===
function updatePlayerState() {
  if (actionPlaying) return;

  if (keys["x"]) { playerState = "dead"; return; }

  if ((jumping || debugModeJumpAttacks) && keys["c"]) {
    playerState = "jump_attack";
    actionPlaying = true;
    currentFrame = 0;
    return;
  }
  if ((jumping || debugModeJumpAttacks) && keys["v"]) {
    playerState = "jump_throw";
    actionPlaying = true;
    currentFrame = 0;
    shootProjectile(x + spriteWidth / 2, y - spriteHeight / 2, facingRight ? 1 : -1);
    return;
  }

  if (keys["z"]) { playerState = "slide"; return; }

  if (keys["d"] && !jumping) {
    actionPlaying = true; currentFrame = 0; playerState = "attack"; return;
  }
  if (keys["f"] && !jumping) {
    actionPlaying = true; currentFrame = 0; playerState = "throw"; 
    shootProjectile(x + spriteWidth / 2, y - spriteHeight / 2, facingRight ? 1 : -1);
    return;
  }

  if (jumping && !["jump_attack","jump_throw"].includes(playerState)) {
    playerState = "jump"; return;
  }

  if (!jumping && keys["arrowup"]) {
    jumping = true;
    velocityY = -jumpBoost;
    if (keys["arrowleft"]) { jumpHorizontalSpeed = -2.5; facingRight = false; }
    else if (keys["arrowright"]) { jumpHorizontalSpeed = 2.5; facingRight = true; }
    else jumpHorizontalSpeed = 0;
    playerState = "jump";
  } else if (!jumping && (keys["arrowleft"] || keys["arrowright"])) {
    playerState = "run";
  } else if (!jumping) {
    playerState = "idle";
  }
}

// === ACTUALIZAR POSICIÓN ===
function updatePosition() {
  if (jumping) {
    velocityY += gravity;
    y += velocityY;
    x += jumpHorizontalSpeed;

    if (y >= 350) {
      y = 350;
      jumping = false;
      velocityY = 0;
      jumpHorizontalSpeed = 0;
    }
  }

  if (!jumping && playerState === "run") {
    if (keys["arrowleft"]) { x -= speedRun; facingRight = false; }
    if (keys["arrowright"]) { x += speedRun; facingRight = true; }
  }

  if (x < 0) x = 0;
  if (x > canvas.width - spriteWidth) x = canvas.width - spriteWidth;
}

// === OBTENER FRAMES ===
function getAnimationFrames() {
  return { frames: animations[playerState], count: frameCount };
}

// === DIBUJAR SPRITE CON ESCALA X/Y Y SUAVIZADO ===
function drawSprite(frames, currentFrame, x, y, width, height, facingRight = true, state) {
  ctx.save();
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  const factor = scaleFactors[state] || scaleFactors.default;
  const scaleX = factor.x;
  const scaleY = factor.y;

  const drawW = Math.round(width * scaleX);
  const drawH = Math.round(height * scaleY);
  const offsetX = Math.round(x + (width - drawW) / 2);
  const offsetY = Math.round(y - (height - drawH) / 2);

  if (!facingRight) {
    ctx.translate(offsetX + drawW / 2, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(frames[currentFrame], -drawW / 2, offsetY - drawH, drawW, drawH);
  } else {
    ctx.drawImage(frames[currentFrame], offsetX, offsetY - drawH, drawW, drawH);
  }
  ctx.restore();
}

// === GAME LOOP ===
function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  updatePlayerState();
  updatePosition();

  const { frames, count } = getAnimationFrames();
  drawSprite(frames, currentFrame, x, y, spriteWidth, spriteHeight, facingRight, playerState);

  // Dibujar enemigo
  ctx.fillStyle = enemy.color;
  ctx.fillRect(enemy.x, enemy.y - enemy.height, enemy.width, enemy.height);

  // Dibujar proyectiles con Kunai girando en sentido de lanzamiento y escalados
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.x += p.speed * p.dir;

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";

    const scale = 1.2;
    const drawW = 15 * scale;
    const drawH = 30 * scale;
    const centerX = p.x + drawW / 2;
    const centerY = p.y + drawH / 2;

    ctx.translate(centerX, centerY);
    const angle = p.dir > 0 ? Math.PI / 2 : -Math.PI / 2;
    ctx.rotate(angle);

    ctx.drawImage(projectileImg, -drawW / 2, -drawH / 2, drawW, drawH);
    ctx.restore();

    if (p.x < -drawW || p.x > canvas.width + drawW) projectiles.splice(i, 1);
  }

  frameCounter++;
  const delay = animationDelays[playerState] || animationDelays.default;

  if (frameCounter % delay === 0) {
    currentFrame++;
    if ((playerState === "attack" || playerState === "throw" || playerState === "jump_attack" || playerState === "jump_throw") && currentFrame >= count) {
      actionPlaying = false;
      currentFrame = 0;
      playerState = jumping ? "jump" : (keys["arrowleft"] || keys["arrowright"] ? "run" : "idle");
    } else {
      currentFrame %= count;
    }
  }

  requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>
