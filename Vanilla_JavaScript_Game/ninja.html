<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Ninja Animaciones</title>
  <style>
    body {
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid white;
      background: #444;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="500" height="400"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// === FRAMES ===
const frameCount = 10;
const animations = {
  run: [], idle: [], attack: [], jump: [],
  dead: [], slide: [], jump_throw: [], jump_attack: [], throw: []
};
let loaded = 0;

// Preload todas las animaciones
function preloadImages(folder, array) {
  for (let i = 1; i <= frameCount; i++) {
    const img = new Image();
    img.src = `ninja/${folder}/frame_${i}.png`;
    img.onload = () => {
      loaded++;
      if (loaded === Object.keys(animations).length * frameCount) {
        requestAnimationFrame(gameLoop);
      }
    };
    array.push(img);
  }
}

for (let anim in animations) preloadImages(anim, animations[anim]);

// === VARIABLES ===
let x = 200, y = 350;
const spriteWidth = 80, spriteHeight = 80;
const speedRun = 5;
const jumpBoost = 6;
const jumpAccel = 0.4;
let jumpY = 0;
let jumping = false;
let facingRight = true;
let jumpHorizontalSpeed = 0;

let actionPlaying = false; // controla attack y throw

const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

let playerState = "idle";
let currentFrame = 0;
let frameCounter = 0;

// === ACTUALIZAR ESTADO DEL JUGADOR ===
function updatePlayerState() {
  // Proteger animaciones que se reproducen completas
  if (actionPlaying) return;

  if (keys["x"]) {
    playerState = "dead";
    return;
  }

  if (jumping && keys["c"]) {
    playerState = "jump_attack";
    return;
  }

  if (jumping && keys["v"]) {
    playerState = "jump_throw";
    return;
  }

  if (keys["z"]) {
    playerState = "slide";
    return;
  }

  if (keys["d"] && !jumping) {
    actionPlaying = true;
    currentFrame = 0;
    playerState = "attack";
    return;
  }

  if (keys["t"] && !jumping) {
    actionPlaying = true;
    currentFrame = 0;
    playerState = "throw";
    return;
  }

  if (jumping && !["jump_attack","jump_throw"].includes(playerState)) {
    playerState = "jump";
    return;
  }

  if (keys["ArrowUp"] && !jumping) {
    jumping = true;
    jumpY = 0;
    if (keys["ArrowLeft"]) jumpHorizontalSpeed = -2, facingRight = false;
    else if (keys["ArrowRight"]) jumpHorizontalSpeed = 2, facingRight = true;
    else jumpHorizontalSpeed = 0;
    playerState = "jump";
  } else if (keys["ArrowLeft"] || keys["ArrowRight"]) {
    playerState = "run";
  } else {
    playerState = "idle";
  }
}

// === ACTUALIZAR POSICIÓN ===
function updatePosition() {
  if (!jumping && playerState === "run") {
    if (keys["ArrowLeft"]) x -= speedRun, facingRight = false;
    if (keys["ArrowRight"]) x += speedRun, facingRight = true;
  }

  if (jumping) {
    if (keys["ArrowLeft"]) jumpHorizontalSpeed = Math.max(jumpHorizontalSpeed - jumpAccel, -jumpBoost), facingRight = false;
    else if (keys["ArrowRight"]) jumpHorizontalSpeed = Math.min(jumpHorizontalSpeed + jumpAccel, jumpBoost), facingRight = true;

    x += jumpHorizontalSpeed;
    jumpY += 5;

    if (jumpY >= 50) {
      jumpY = 50;
      setTimeout(() => {
        jumping = false;
        jumpY = 0;
        jumpHorizontalSpeed = 0;
      }, 200);
    }
  }

  if (x < 0) x = 0;
  if (x > canvas.width - spriteWidth) x = canvas.width - spriteWidth;
  if (y - jumpY > canvas.height) y = canvas.height;
}

// === OBTENER FRAMES ===
function getAnimationFrames() {
  return { frames: animations[playerState], count: frameCount };
}

// === DIBUJAR SPRITE ===
function drawSprite(frames, currentFrame, x, y, width, height, facingRight = true) {
  ctx.save();
  if (!facingRight) {
    ctx.translate(x + width / 2, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(frames[currentFrame], -width / 2, y - height, width, height);
  } else {
    ctx.drawImage(frames[currentFrame], x, y - height, width, height);
  }
  ctx.restore();
}

// === GAME LOOP ===
function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  updatePlayerState();
  updatePosition();

  const { frames, count } = getAnimationFrames();
  drawSprite(frames, currentFrame, x, y - jumpY, spriteWidth, spriteHeight, facingRight);

  frameCounter++;
  const delay = 6;
  if (frameCounter % delay === 0) {
    currentFrame++;

    // Si era attack o throw y terminó
    if ((playerState === "attack" || playerState === "throw") && currentFrame >= count) {
      actionPlaying = false;
      currentFrame = 0;
      playerState = jumping ? "jump" : (keys["ArrowLeft"] || keys["ArrowRight"] ? "run" : "idle");
    } else {
      currentFrame %= count;
    }
  }

  requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>
