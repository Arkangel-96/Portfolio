<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Ninja Debug Hitbox Mejorado</title>
<style>
body {
  background: #222;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
canvas {
  border: 2px solid white;
  background: #444;
}
</style>
</head>
<body>
<canvas id="gameCanvas" width="500" height="400"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// === CONFIGURACIÓN DE FRAMES ===
const frameCount = 10;
const animations = {
  run: [], idle: [], attack: [], throw: [],
  dead: [], slide: [], jump: [], jump_attack: [], jump_throw: []
};
let loaded = 0;

// Precarga de imágenes
function preloadImages(folder, array) {
  for (let i = 1; i <= frameCount; i++) {
    const img = new Image();
    img.src = `ninja/${folder}/frame_${i}.png`;
    img.onload = () => {
      loaded++;
      if (loaded === Object.keys(animations).length * frameCount) {
        requestAnimationFrame(gameLoop);
      }
    };
    array.push(img);
  }
}
for (let anim in animations) preloadImages(anim, animations[anim]);

// === HITBOX Y SPRITE SEPARADOS ===
const hitbox = { x: 200, y: 270, w: 50, h: 80 }; // posición física
const spriteWidth = 80, spriteHeight = 80;       // tamaño visual
let facingRight = true;

// === ESTADO DEL JUGADOR ===
let velocityY = 0;
let jumpHorizontalSpeed = 0;
let jumping = false;
let actionPlaying = false;
const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

let playerState = "idle";
let currentFrame = 0;
let frameCounter = 0;

// === ESCALADO X/Y Y OFFSETS ===
const scaleFactors = { 
  idle:        { x: 0.7, y: 1.0 }, 
  attack:      { x: 1.5, y: 1.2 },
  throw:       { x: 1.03, y: 1.03 },
  dead:        { x: 1.2, y: 1.2 },
  jump_attack: { x: 1.3, y: 1.3 },
  default:     { x: 1.0, y: 1.0 }
};
const animationOffsets = {
  attack:      { x: 0, y: 15 }, 
  jump_attack: { x: 0, y: 20 }, 
  default:     { x: 0, y: 0 }
};
const animationDelays = { idle: 10, jump: 12, default: 6 };

// === SALTO Y GRAVEDAD ===
const jumpBoost = 7;
const gravity = 0.15;

// === PROYECTILES ===
let projectiles = [];
function shootProjectile(startX, startY, direction) {
  projectiles.push({ x: startX, y: startY, speed: 6, dir: direction });
}

// === CUBO DE PRUEBA ===
let enemy = { x: 300, y: 350, w: 80, h: 80 };

// === FUNCIONES DE ESTADO ===
function updatePlayerState() {
  if (actionPlaying) return;

  if (keys["x"]) { playerState = "dead"; return; }
  
  // Actualizar dirección del sprite según movimiento lateral
  if (!jumping) {
    if (keys["arrowleft"]) facingRight = false;
    else if (keys["arrowright"]) facingRight = true;
}

  if ((jumping) && keys["c"]) {
    playerState = "jump_attack";
    actionPlaying = true;
    currentFrame = 0;
    return;
  }
  if ((jumping) && keys["v"]) {
    playerState = "jump_throw";
    actionPlaying = true;
    currentFrame = 0;
    shootProjectile(hitbox.x + hitbox.w/2, hitbox.y + hitbox.h/2, facingRight?1:-1);
    return;
  }

  if (keys["z"]) { playerState = "slide"; return; }

  if (keys["d"] && !jumping) {
    actionPlaying = true; currentFrame=0; playerState="attack"; return;
  }
  if (keys["f"] && !jumping) {
    actionPlaying = true; currentFrame=0; playerState="throw";
    shootProjectile(hitbox.x + hitbox.w/2, hitbox.y + hitbox.h/2, facingRight?1:-1);
    return;
  }

  if (jumping && !["jump_attack","jump_throw"].includes(playerState)) playerState="jump";
  
  if (!jumping && keys["arrowup"]) {
    jumping = true;
    velocityY = -jumpBoost;
    if (keys["arrowleft"]) { jumpHorizontalSpeed=-2.5; facingRight=false; }
    else if (keys["arrowright"]) { jumpHorizontalSpeed=2.5; facingRight=true; }
    else jumpHorizontalSpeed=0;
    playerState="jump";
  } else if (!jumping && (keys["arrowleft"] || keys["arrowright"])) playerState="run";
  else if (!jumping) playerState="idle";
}

// === ACTUALIZAR POSICIÓN CON COLISIONES SUAVES ===
function updatePosition() {
  const prevX = hitbox.x;
  const prevY = hitbox.y;

  // Movimiento horizontal
  let dx = 0;
  if (!jumping) {
    if (keys["arrowleft"]) dx=-5;
    if (keys["arrowright"]) dx=5;
  }

  hitbox.x += dx + jumpHorizontalSpeed;

  // Colisión horizontal con cubo
  if (hitbox.x + hitbox.w > enemy.x &&
      hitbox.x < enemy.x + enemy.w &&
      hitbox.y + hitbox.h > enemy.y - enemy.h &&
      hitbox.y < enemy.y) {
    hitbox.x = prevX;
  }

  // Movimiento vertical
  velocityY += gravity;
  hitbox.y += velocityY;

  // Colisión vertical (solo si cae)
  if (velocityY > 0) {
    if (hitbox.x + hitbox.w > enemy.x &&
        hitbox.x < enemy.x + enemy.w) {
      const hitboxBottomPrev = prevY + hitbox.h;
      const enemyTop = enemy.y - enemy.h;
      const hitboxBottomCurr = hitbox.y + hitbox.h;

      if (hitboxBottomPrev <= enemyTop && hitboxBottomCurr >= enemyTop) {
        hitbox.y = enemyTop - hitbox.h;
        velocityY = 0;
        jumping = false;
      }
    }
  }

  // Colisión con suelo
  if (hitbox.y + hitbox.h > 350) {
    hitbox.y = 350 - hitbox.h;
    velocityY = 0;
    jumping = false;
  }

  // Límites del canvas
  if (hitbox.x < 0) hitbox.x = 0;
  if (hitbox.x + hitbox.w > canvas.width) hitbox.x = canvas.width - hitbox.w;

  // Mantener impulso horizontal mientras salta
  if (jumping) {
    jumpHorizontalSpeed *= 0.98; // ligera fricción aérea
  } else {
    jumpHorizontalSpeed = 0;
  }
}

// === DIBUJAR SPRITE ===
function drawSprite(frames, currentFrame, hitbox, state) {
  ctx.save();
  ctx.imageSmoothingEnabled=true;
  ctx.imageSmoothingQuality="high";
  const factor = scaleFactors[state] || scaleFactors.default;
  const offset = animationOffsets[state] || animationOffsets.default;
  const drawW = Math.round(spriteWidth * factor.x);
  const drawH = Math.round(spriteHeight * factor.y);
  const drawX = hitbox.x + (hitbox.w - drawW)/2 + offset.x;
  const drawY = hitbox.y + (hitbox.h - drawH) + offset.y;

  if (!facingRight) {
    ctx.translate(drawX + drawW/2,0);
    ctx.scale(-1,1);
    ctx.drawImage(frames[currentFrame], -drawW/2, drawY, drawW, drawH);
  } else ctx.drawImage(frames[currentFrame], drawX, drawY, drawW, drawH);
  ctx.restore();
}

// === GAME LOOP ===
function gameLoop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  updatePlayerState();
  updatePosition();

  const { frames,count } = { frames: animations[playerState], count: frameCount };
  drawSprite(frames, currentFrame, hitbox, playerState);

  // Dibujar cubo
  ctx.fillStyle="orange";
  ctx.fillRect(enemy.x, enemy.y - enemy.h, enemy.w, enemy.h);

  // Dibujar hitbox
  ctx.strokeStyle="lime";
  ctx.strokeRect(hitbox.x, hitbox.y, hitbox.w, hitbox.h);

  // Proyectiles
  for (let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    p.x+=p.speed*p.dir;
    ctx.fillStyle="green";
    ctx.fillRect(Math.round(p.x), Math.round(p.y), 10, 10);
    if (p.x<enemy.x+enemy.w && p.x+10>enemy.x &&
        p.y<enemy.y && p.y+10>enemy.y-enemy.h) { projectiles.splice(i,1); }
    if (p.x<0 || p.x>canvas.width) projectiles.splice(i,1);
  }

  frameCounter++;
  const delay = animationDelays[playerState] || animationDelays.default;
  if (frameCounter % delay === 0){
    currentFrame++;
    if ((playerState==="attack"||playerState==="throw"||
         playerState==="jump_attack"||playerState==="jump_throw") &&
        currentFrame>=count) {
      actionPlaying=false;
      currentFrame=0;
      playerState = jumping ? "jump" : ((keys["arrowleft"]||keys["arrowright"])?"run":"idle");
    } else currentFrame%=count;
  }

  requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>
